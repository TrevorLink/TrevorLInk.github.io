

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Noctis64">
  <meta name="keywords" content="">
  
    <meta name="description" content="目前的工作是正在找工作 orz">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 八股">
<meta property="og:url" content="http://example.com/2024/01/05/Java%20%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Zanarkand">
<meta property="og:description" content="目前的工作是正在找工作 orz">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240103155808731.png">
<meta property="og:image" content="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231229192650729.png">
<meta property="og:image" content="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240110080422323.png">
<meta property="og:image" content="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231229115631317.png">
<meta property="og:image" content="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231229115725856.png">
<meta property="og:image" content="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240101165746438.png">
<meta property="og:image" content="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231231161239265.png">
<meta property="og:image" content="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231231161120569.png">
<meta property="article:published_time" content="2024-01-05T02:12:01.000Z">
<meta property="article:modified_time" content="2024-05-15T15:07:09.772Z">
<meta property="article:author" content="Noctis64">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240103155808731.png">
  
  
  
  <title>Java 八股 - Zanarkand</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"gtag":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Zanarkand</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java 八股"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-05 10:12" pubdate>
          2024年1月5日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          103 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java 八股</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Java语法基础"><a href="#Java语法基础" class="headerlink" title="Java语法基础"></a>Java语法基础</h1><h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h2 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM JDK JRE"></a>JVM JDK JRE</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JVM是指运行 Java 字节码的一个虚拟机，<strong>对不同的平台系统有特定的实现</strong>，程序员只需要编写相同的 Java 代码，交由 JVM 运行字节码，实现跨平台， <strong>字节码和不同系统的 JVM 实现</strong>是 Java 语言 <code>一次编译，随处可以运行</code> 的关键所在</p>
<p>最常用的 JVM 是 Hotspot JVM</p>
<h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>Java 运行时环境，它是<strong>运行已编译 Java 程序所需的所有内容的集合</strong>，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）</p>
<p>JRE 仅包含 Java 应用程序的运行时环境和必要的类库</p>
<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>包含一系列开发功能的 JAVA SDK 提供给开发者用的，用于创建和编译 Java 程序</p>
<p>JDK 包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等</p>
<p>此外，对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码。因此，即使不打算进行 Java 应用程序的开发工作，也有可能需要安装 JDK</p>
<p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240103155808731.png" srcset="/img/loading.gif" lazyload alt="三者的区别"></p>
<h2 id="如何理解-Java-的编译与解释并存"><a href="#如何理解-Java-的编译与解释并存" class="headerlink" title="如何理解 Java 的编译与解释并存"></a>如何理解 Java 的编译与解释并存</h2><p><strong>编译型</strong>：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80">编译型语言</a> 会通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a>将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</p>
<p><strong>解释型</strong>：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80">解释型语言</a>会通过<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8">解释器</a>一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</p>
<p>至于为什么说 Java 的编译和解释共存，主要是 Java 先经过编译生成 <strong>字节码</strong> 文件，之后 <strong>JVM 类加载器首先加载字节码文件，再由解释器逐行解释运行</strong>（针对热点代码有 JIT 编译器）</p>
<h2 id="采用字节码的好处"><a href="#采用字节码的好处" class="headerlink" title="采用字节码的好处"></a>采用字节码的好处</h2><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它<strong>不面向任何特定的处理器，只面向虚拟机</strong></p>
<p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</p>
<p>所以， Java 程序运行时相对来说还是高效的（不过，和 C、 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序<strong>无须重新编译便可在多种不同操作系统的计算机上运行</strong></p>
<p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231229192650729.png" srcset="/img/loading.gif" lazyload></p>
<p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器<strong>逐行解释</strong>执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 <strong>JIT（Just in Time Compilation）</strong> 编译器，而 JIT 属于<strong>运行时编译</strong>：</p>
<p><strong>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用</strong>。而我们知道，直接获得机器码的运行效率肯定是高于再去走 Java 解释器的</p>
<p>这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong></p>
<h2 id="标识符和关键字的区别"><a href="#标识符和关键字的区别" class="headerlink" title="标识符和关键字的区别"></a>标识符和关键字的区别</h2><p>标识符 Identifier 其实就是我们编码的过程中的名字，马甲，称呼</p>
<p><strong>关键字是特殊含义的标识符</strong></p>
<h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode()"></a>hashcode()</h2><p>本身是 Object 类的方法，带有 native 关键字是用 C&#x2F;CPP 来实现的</p>
<p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></p>
<p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，<strong>判断元素是否在对应容器中的效率会更高</strong>（参考添加元素进<code>HashSet</code>的过程）！</p>
<p>我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
<p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></p>
<p>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
<p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p>
<p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
<p>总结下来就是：</p>
<ul>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ul>
<h2 id="String为什么不可变"><a href="#String为什么不可变" class="headerlink" title="String为什么不可变"></a>String为什么不可变</h2><p><code>String</code> 真正不可变有下面几点原因：</p>
<ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h2 id="String参数传递"><a href="#String参数传递" class="headerlink" title="String参数传递"></a>String参数传递</h2><p>字符串在 Java 中是通过引用传递的，但由于字符串的不可变性，对字符串的任何修改都会创建一个新的字符串对象。因此，原始的字符串对象不会受到方法内部修改的影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringParameterExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;Before method call: &quot;</span> + original);<br>        modifyString(original);<br>        System.out.println(<span class="hljs-string">&quot;After method call: &quot;</span> + original);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyString</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">// 在方法内部修改字符串，实际上是创建了一个新的字符串对象</span><br>        str = str + <span class="hljs-string">&quot; World&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;Inside method: &quot;</span> + str);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="Object类的方法有哪些"><a href="#Object类的方法有哪些" class="headerlink" title="Object类的方法有哪些"></a>Object类的方法有哪些</h2><p>1．clone方法</p>
<p> 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出 CloneNotSupportedException 异常。</p>
<p> 主要是JAVA里<strong>除了 8 种基本类型 (byte short int long float double char boolean ) + String + 包装数据类型 传参数是值传递</strong>，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。</p>
<p> 2．getClass方法</p>
<p> final方法，获得运行时类型。</p>
<p> 3．toString方法</p>
<p> 该方法用得比较多，一般子类都有覆盖。</p>
<p> 4．finalize方法</p>
<p> 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p>
<p> 5．equals方法</p>
<p> 该方法是非常重要的一个方法。一般equals和=&#x3D;是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p>
<p> 6．hashCode方法</p>
<p> 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p>
<p> 一般必须满足obj1.equals(obj2)=&#x3D;true。可以推出obj1.hash- Code()&#x3D;&#x3D;obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p>
<p> 如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。</p>
<p> 7．wait方法</p>
<p> wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p>
<p> 调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p>
<p> （1）其他线程调用了该对象的 notify 方法。</p>
<p> （2）其他线程调用了该对象的 notifyAll 方法。</p>
<p> （3）其他线程调用了 interrupt 中断该线程。</p>
<p> （4）时间间隔到了。</p>
<p> 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p>
<p> 8．notify方法</p>
<p> 该方法唤醒在该对象上等待的某个线程。</p>
<p> 9．notifyAll方法</p>
<p> 该方法唤醒在该对象上等待的所有线程。</p>
<h2 id="如何比较两个对象"><a href="#如何比较两个对象" class="headerlink" title="如何比较两个对象"></a>如何比较两个对象</h2><p>两种方法：</p>
<ul>
<li>equals</li>
<li>compareTo</li>
</ul>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>在Java中，每个类都继承自 <code>Object</code> 类，而 <code>Object</code> 类中有一个<code>equals()</code>方法。<strong>默认情况下，<code>equals()</code>方法实现是比较对象的引用是否相等，即比较两个对象是否是同一个对象</strong>。</p>
<p>如果你想在自定义类中比较对象的内容而非引用，你需要覆盖<code>equals()</code>方法，并在其中实现你自己的比较逻辑。通常，你需要比较对象的属性来确定它们是否相等。</p>
<h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h3><p>如果你的类实现了<code>Comparable</code>接口，你可以使用<code>compareTo()</code>方法来比较两个对象的大小。这通常用于排序操作。</p>
<h2 id="函数签名三要素"><a href="#函数签名三要素" class="headerlink" title="函数签名三要素"></a>函数签名三要素</h2><p>方法名，参数列表，返回值</p>
<p>通过这三点来确定一个函数</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>发生在编译期，同一个类中（或者<strong>父类和子类之间也可以</strong>），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写发生在<strong>运行期</strong>，是<strong>子类对父类的允许访问的方法</strong>的实现过程进行重新编写。</p>
<ol>
<li><strong>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类</strong>（两同两小一大）</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，<strong>如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象</strong>。</p>
<p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，<strong>包括这个对象所包含的内部对象</strong>。</p>
<p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240110080422323.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="几种实现"><a href="#几种实现" class="headerlink" title="几种实现"></a>几种实现</h2><p>一种是基于JDK实现的，另一种是 CGLIB ，还有ASM的实现</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：提供了在程序运行时获取和执行任意一个类中的方法，代码更加灵活</p>
<p>缺点：安全问题：无视泛型的类型检查（因为泛型的类型检查发生在编译期间）</p>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>输入输出（I&#x2F;O）流是Java中用于处理输入和输出的一组机制。</p>
<p>I&#x2F;O流以字节或字符为单位传输数据，用于与文件、网络、设备等进行数据交互。在Java中，I&#x2F;O流主要<strong>分为字节流和字符流</strong>两种类型。</p>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream</code>&#x2F;<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>&#x2F;<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>在 Java 中一个字符一般认为相当于 2 个字节</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化），<code>ObjectOutputStream</code> 用于将对象写入到输出流(序列化)</p>
<p>另外，用于序列化和反序列化的类必须实现 <code>Serializable</code> 接口</p>
<p>对象中如果有属性不想被序列化，使用 <code>transient</code> 修饰</p>
<h2 id="有了字节流为什么还需要字符流"><a href="#有了字节流为什么还需要字符流" class="headerlink" title="有了字节流为什么还需要字符流"></a>有了字节流为什么还需要字符流</h2><ul>
<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li>
<li>如果我们不知道编码类型就很容易出现乱码问题。</li>
</ul>
<p>对于文本类型包含字符数据的，直接用字节流会出现编码格式导致的乱码问题，因此I&#x2F;O 流就干脆提供了一个<strong>直接操作字符</strong>的接口，方便我们平时对字符进行流操作。</p>
<p><strong>如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</strong></p>
<p>字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码</p>
<p>顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？</p>
<p><code>utf8</code> :英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2 个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取&#x2F;写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p>
<p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建一个 BufferedInputStream 对象</span><br><span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 <code>write(int b)</code> 和 <code>read()</code> 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><h2 id="Spring支持的事务类型有哪些"><a href="#Spring支持的事务类型有哪些" class="headerlink" title="Spring支持的事务类型有哪些"></a>Spring支持的事务类型有哪些</h2><ul>
<li>声明式</li>
<li>编程式</li>
<li>基于注解</li>
<li>注解驱动</li>
<li>全局事务</li>
</ul>
<h2 id="AOP的应用"><a href="#AOP的应用" class="headerlink" title="AOP的应用"></a>AOP的应用</h2><ul>
<li>日志</li>
<li>事务</li>
<li>异常处理</li>
<li>性能监控</li>
</ul>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="SpringBoot核心入口"><a href="#SpringBoot核心入口" class="headerlink" title="SpringBoot核心入口"></a>SpringBoot核心入口</h2><p>在Spring Boot应用中，核心的入口点是<code>SpringApplication</code>类。具体来说，Spring Boot应用的启动是通过<code>public static void main(String[] args)</code>方法实现的，该方法通常位于一个包含<code>@SpringBootApplication</code>注解的主类中。这个主类是Spring Boot应用的启动类，同时也是<code>SpringApplication</code>的一个参数。</p>
<p>以下是一个简单的Spring Boot应用启动类示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MyApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyApplication</code>类上使用了<code>@SpringBootApplication</code>注解，它包含了多个元注解，其中之一是<code>@SpringBootConfiguration</code>，它表明这是一个Spring Boot配置类。<code>main</code>方法使用<code>SpringApplication.run</code>启动了Spring Boot应用，传递了<code>MyApplication.class</code>作为主要的启动类，以及<code>args</code>数组作为命令行参数。</p>
<h2 id="SpringBoot常见注解"><a href="#SpringBoot常见注解" class="headerlink" title="SpringBoot常见注解"></a>SpringBoot常见注解</h2><p><strong><code>@SpringBootApplication</code></strong></p>
<ul>
<li>包含**<code>@SpringBootConfiguration</code>**<ul>
<li>包含**<code>@Configuration</code>**</li>
</ul>
</li>
</ul>
<p>@<strong><code>RestController</code></strong></p>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="简单介绍一下是什么"><a href="#简单介绍一下是什么" class="headerlink" title="简单介绍一下是什么"></a>简单介绍一下是什么</h2><p>Spring MVC（Model-View-Controller）是Spring框架的一个模块，用于支持构建基于模型-视图-控制器设计模式的Web应用程序</p>
<p>它提供了一个灵活的、基于注解的Web框架，用于开发和部署Web应用程序</p>
<p>Spring MVC被设计为与Spring框架的其他模块（如Spring Core和Spring Data等）无缝集成，提供了一种结构化和模块化的方式来构建Web应用程序</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EagerSingleton</span> &#123;<br><br>    <span class="hljs-comment">// 在类加载时就创建单例实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">EagerSingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EagerSingleton</span>();<br><br>    <span class="hljs-comment">// 私有构造方法，防止外部实例化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">EagerSingleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// 全局访问点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> EagerSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleLazySingleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SimpleLazySingleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SimpleLazySingleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SimpleLazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 懒汉式，在第一次请求时创建实例</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleLazySingleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>线程安全问题？饿汉式是线程安全的，懒汉式不安全</p>
<p>可以通过双重锁定+同步块来解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleCheckedLazySingleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> DoubleCheckedLazySingleton instance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DoubleCheckedLazySingleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleCheckedLazySingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 双重检查锁定</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (DoubleCheckedLazySingleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleCheckedLazySingleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="装饰器设计模式"><a href="#装饰器设计模式" class="headerlink" title="装饰器设计模式"></a>装饰器设计模式</h2><p>缓冲流是I&#x2F;O流中的一种装饰器，它提供了对底层字节流（或字符流）的缓冲功能，以提高I&#x2F;O性能。在Java中，缓冲流通常通过 <code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>（用于字节流）以及 <code>BufferedReader</code> 和 <code>BufferedWriter</code>（用于字符流）来实现。这些类都是装饰器类，采用了装饰器设计模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedStreamsExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建文件输入流</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;input.txt&quot;</span>);<br>             <span class="hljs-comment">// 将文件输入流包装在缓冲输入流中</span><br>             <span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(fileInputStream);<br>             <span class="hljs-comment">// 创建文件输出流</span><br>             <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br>             <span class="hljs-comment">// 将文件输出流包装在缓冲输出流中</span><br>             <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bufferedOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(fileOutputStream)) &#123;<br><br>            <span class="hljs-comment">// 读取数据并写入到输出流</span><br>            <span class="hljs-type">int</span> byteRead;<br>            <span class="hljs-keyword">while</span> ((byteRead = bufferedInputStream.read()) != -<span class="hljs-number">1</span>) &#123;<br>                bufferedOutputStream.write(byteRead);<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;File copied successfully.&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code> 分别包装了 <code>FileInputStream</code> 和 <code>FileOutputStream</code>，提供了缓冲的功能。这样的嵌套使用正是装饰器设计模式的体现，通过一系列装饰器来增强原始的功能。</p>
<p>字符流的缓冲流用法类似，可以使用 <code>BufferedReader</code> 和 <code>BufferedWriter</code> 来提高字符流的性能。</p>
<h1 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h1><h2 id="说说-List-Set-Queue-Map-的几个区别"><a href="#说说-List-Set-Queue-Map-的几个区别" class="headerlink" title="说说 List Set Queue Map 的几个区别"></a>说说 List Set Queue Map 的几个区别</h2><p>List 有序可重复</p>
<p>Set 不可重复，具体有序无序要看实现</p>
<p>Queue FIFO的实现，有序可重复</p>
<p>Map 键值对存储映射</p>
<ul>
<li>key是无序<strong>不可重复</strong>的</li>
<li>value是无序可重复的</li>
<li>一个key最多对应一个value</li>
</ul>
<h2 id="常见的-List-Set-Queue-Map"><a href="#常见的-List-Set-Queue-Map" class="headerlink" title="常见的 List Set Queue Map"></a>常见的 List Set Queue Map</h2><p>List：</p>
<ul>
<li>ArrayList 线程不安全</li>
<li>Vector 线程安全，古早</li>
<li>LinkedList 双向链表，1.6之前还是循环的，但是在1.7之后取消了循环</li>
</ul>
<p>Set：</p>
<p><font color='red'>都是线程不安全的</font></p>
<ul>
<li>HashSet <font color='red'>无序</font>（底层是HashMap）</li>
<li>LinkedHashSet（底层是LinkedHashMap）</li>
<li>TreeSet（有序）</li>
</ul>
<p>Queue：</p>
<ul>
<li>PriorityQueue：优先级队列</li>
<li>DelayQueue</li>
<li>ArrayQueue 可扩容的动态双向数组</li>
</ul>
<p>Map：</p>
<ul>
<li>HashMap <strong>在1.8之前是数组+链表</strong>，数组是主体，链表则是为了解决哈希冲突，拉链法实现的；在1.8以后当一个点上的链表长度大于8的时候就会转化为红黑树（前提也要是数组长度大于64的时候才会转化，小于64则会先进行数组扩容）</li>
<li>LinkedHashMap 继承自 HashMap 同时增加了一条双向链表，使得<strong>可以按插入顺序访问各个 bucket 的节点</strong></li>
<li>HashTable 线程安全，不允许 null 的 key 和 value</li>
<li>TreeMap 红黑树（自平衡的二叉排序树）</li>
</ul>
<h2 id="线程不安全的解决"><a href="#线程不安全的解决" class="headerlink" title="线程不安全的解决"></a>线程不安全的解决</h2><p>我们都知道ArrayList是线程不安全的，多个线程对同一个List进行写或者是删除的操作可能会导致数据冲突</p>
<p>为了确保线程安全，可以使用 <code>Collections.synchronizedList</code> 或者 <code>CopyOnWriteArrayList</code> 等线程安全的替代品，或者在访问 <code>ArrayList</code> 时手动进行同步</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>它通过<strong>在写操作时创建原始数据的拷贝来实现线程安全性</strong>，这使得读操作可以在不受写操作干扰的情况下进行。适用于<strong>读多写少</strong>的场景，对于迭代操作也是安全的。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>加入操作默认是最后一位加入，操作是O(1)，删除中间指定位置的就是O(n)因为要移动</p>
<p><strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p>
<h1 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h1><h2 id="Java中创建线程的方法"><a href="#Java中创建线程的方法" class="headerlink" title="Java中创建线程的方法"></a>Java中创建线程的方法</h2><p>主要是两个</p>
<p>继承Thread类重写run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot; Value &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br><br>        <span class="hljs-comment">// 启动线程</span><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>实现 Runnable 接口，把这个类的实例传递作为 Thread 构造函数的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot; Value &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br><br>        <span class="hljs-comment">// 启动线程</span><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a>可以直接调用 Thread 类的 run 方法吗？</h2><p>这是另一个非常经典的 Java 多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。</p>
<p>但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结：调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h2 id="Volatile-关键字"><a href="#Volatile-关键字" class="headerlink" title="Volatile 关键字"></a>Volatile 关键字</h2><p>保证多线程环境下变量的可见性，但是不保证针对变量的操作是原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatoleAtomicityDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">inc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123;<br>        inc++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">VolatoleAtomicityDemo</span> <span class="hljs-variable">volatoleAtomicityDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatoleAtomicityDemo</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">500</span>; j++) &#123;<br>                    volatoleAtomicityDemo.increase();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 等待1.5秒，保证上面程序执行完成</span><br>        Thread.sleep(<span class="hljs-number">1500</span>);<br>        System.out.println(inc);<br>        threadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能</p>
<h3 id="公平锁和非公平锁的区别"><a href="#公平锁和非公平锁的区别" class="headerlink" title="公平锁和非公平锁的区别"></a>公平锁和非公平锁的区别</h3><p><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p>
<p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p>
<p>synchronized 默认是非公平，ReentrantLock 可以自定义公平和非公平</p>
<h3 id="可重入锁指的是什么"><a href="#可重入锁指的是什么" class="headerlink" title="可重入锁指的是什么"></a>可重入锁指的是什么</h3><p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p>
<p>JDK 提供的所有现成的 <code>Lock</code> 实现类，包括 <code>synchronized</code> 关键字锁都是可重入的。</p>
<p>在下面的代码中，<code>method1()</code> 和 <code>method2()</code>都被 <code>synchronized</code> 关键字修饰，<code>method1()</code>调用了<code>method2()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法1&quot;</span>);<br>        method2();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于 <code>synchronized</code>锁是可重入的，同一个线程在调用<code>method1()</code> 时可以直接获得当前对象的锁，执行 <code>method2()</code> 的时候可以再次获取这个对象的锁，不会产生死锁问题。假如<code>synchronized</code>是不可重入锁的话，由于该对象的锁已被当前线程所持有且无法释放，这就导致线程在执行 <code>method2()</code>时获取锁失败，会出现死锁问题。</p>
<h3 id="可中断锁和不可中断锁有什么区别？"><a href="#可中断锁和不可中断锁有什么区别？" class="headerlink" title="可中断锁和不可中断锁有什么区别？"></a>可中断锁和不可中断锁有什么区别？</h3><ul>
<li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li>
<li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231229115631317.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231229115725856.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="什么时候用-TCP-什么时候用-UDP"><a href="#什么时候用-TCP-什么时候用-UDP" class="headerlink" title="什么时候用 TCP 什么时候用 UDP"></a>什么时候用 TCP 什么时候用 UDP</h2><p><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</p>
<p><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等</p>
<h2 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h2><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手?"></a>为什么要三次握手?</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ol>
<li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<p>三次握手就能确认双方收发功能都正常，缺一不可</p>
<h2 id="奇偶校验机制"><a href="#奇偶校验机制" class="headerlink" title="奇偶校验机制"></a>奇偶校验机制</h2><p>奇偶校验机制是在数据链路层中一种常见的用于检测bit数据在传输过程中是否发生位错误的一种技术</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><strong>5 种基础数据类型</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）</p>
<p><strong>3 种特殊数据类型</strong>：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)</p>
<p>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>缓存、分布式锁</p>
<p>具体数据类型以及对应的应用场景如下：</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>可以缓存网页内容，存储简单的数据对象例如验证码等kv键值对，就是最简单的 kv 存储</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">SET page:/home <span class="hljs-string">&quot;&lt;html&gt;...&lt;/html&gt;&quot;</span> <span class="hljs-comment">#被频繁访问的网页内容本体可以缓存在 Redis 中</span><br>GET page:/home<br></code></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>有序的字符串<strong>列表</strong>(说是列表其实是一个队列)</p>
<p>可以用 list 数据结构实现最简单的一个消息队列模型</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">LPUSH queue:tasks <span class="hljs-string">&quot;task1&quot;</span><br>LPUSH queue:tasks <span class="hljs-string">&quot;task2&quot;</span><br>RPOP queue:tasks<br></code></pre></td></tr></table></figure>

<p>可以使用 Redis 列表实现简单的消息队列，LPUSH 用于添加任务，RPOP 用于消费任务</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 集合数据结构可以实现简单的用户标签系统</p>
<p>同时还可以进行交集并集运算</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">SADD user:1:tags <span class="hljs-string">&quot;redis&quot;</span><br>SADD user:1:tags <span class="hljs-string">&quot;database&quot;</span><br>SADD user:2:tags <span class="hljs-string">&quot;cache&quot;</span><br>SINTER user:1:tags user:2:tags <span class="hljs-comment">#查询两个用户的兴趣交集</span><br></code></pre></td></tr></table></figure>

<p>在社交网络应用中，可以使用 Set 集合存储用户的标签，并进行交集计算，找出共同的兴趣点</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>哈希是键值对集合，我们可以实现对象的存储</p>
<p>相较于 String 只能存储简单的字符串，Hash可以存储多个字段以及他们的值</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">HSET user:1000 name <span class="hljs-string">&quot;John Doe&quot;</span><br>HSET user:1000 email <span class="hljs-string">&quot;john.doe@example.com&quot;</span><br>HGETALL user:1000<br></code></pre></td></tr></table></figure>

<p>Hash 数据结构可以对单个字段进行操作。例如，只修改或获取哈希中的一个字段</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">HSET user:1000 name <span class="hljs-string">&quot;Jane Doe&quot;</span><br>HGET user:1000 name <span class="hljs-comment">#只获取 user:1000 key(集合)的name这一个字段</span><br></code></pre></td></tr></table></figure>

<h3 id="ZSet-x2F-Sorted-Set"><a href="#ZSet-x2F-Sorted-Set" class="headerlink" title="ZSet&#x2F;Sorted Set"></a>ZSet&#x2F;Sorted Set</h3><p>相较于集合而言多了一个权重，可以进行排序</p>
<p>例如在标签的基础上增加一个 weight 权重的设计，或者是设计一个排行榜</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">ZADD leaderboard 1000 <span class="hljs-string">&quot;user1&quot;</span><br>ZADD leaderboard 2000 <span class="hljs-string">&quot;user2&quot;</span><br>ZREVRANGE leaderboard 0 1 WITHSCORES<br></code></pre></td></tr></table></figure>

<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>可以用来实现某一天的签到业务，或者是统计海量用户在某一天的活跃度</p>
<p>一个网站可以使用 Bitmap 来记录用户在某一天是否活跃。假设网站有 1 亿用户，可以使用一个大小为 1 亿位的 Bitmap，其中每一位代表一个用户的活跃状态（0 表示不活跃，1 表示活跃）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">SETBIT active_users:2024-05-14 12345 1  # 用户 ID 为 12345 的用户在 2024-05-14 活跃<br>GETBIT active_users:2024-05-14 12345  # 检查用户 ID 为 12345 的用户在 2024-05-14 是否活跃<br></code></pre></td></tr></table></figure>

<p>采用这个数据结构可以节省大量存储空间，比使用布尔数组更高效</p>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog 是一种基于概率的数据结构，用于估算大规模数据集合的基数（即不同元素的数量）</p>
<p>例如可以实现独立（不同）访客统计，商品去重的访问量</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">PFADD unique_visitors:2024-05-14 user12345  <span class="hljs-comment"># 记录用户 ID 为 user12345 的用户在 2024-05-14 访问</span><br>PFADD unique_visitors:2024-05-14 user67890  <span class="hljs-comment"># 记录用户 ID 为 user67890 的用户在 2024-05-14 访问</span><br>PFCOUNT unique_visitors:2024-05-14  <span class="hljs-comment"># 估算 2024-05-14 的独立访客数量</span><br><br>PFADD product:page:123 user12345  <span class="hljs-comment"># 记录用户 ID 为 user12345 访问了商品页面 123</span><br>PFADD product:page:123 user67890  <span class="hljs-comment"># 记录用户 ID 为 user67890 访问了商品页面 123</span><br>PFCOUNT product:page:123  <span class="hljs-comment"># 估算商品页面 123 的独立访问用户数量</span><br></code></pre></td></tr></table></figure>

<h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p>可以借助 Geospatial 来存储和操作<strong>地理空间数据</strong>，可以进行半径查询、距离计算等操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">GEOADD stores 13.361389 38.115556 <span class="hljs-string">&quot;Palermo&quot;</span><br>GEOADD stores 15.087269 37.502669 <span class="hljs-string">&quot;Catania&quot;</span><br>GEORADIUS stores 15 37 100 km <br></code></pre></td></tr></table></figure>

<p>上面是查询了以 15 37 这一经纬度坐标点为中心，100km为半径的所有商店</p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p>
<p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 <code>dir</code> 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<h2 id="缓存穿透-缓存击穿-缓存雪崩"><a href="#缓存穿透-缓存击穿-缓存雪崩" class="headerlink" title="缓存穿透 缓存击穿 缓存雪崩"></a>缓存穿透 缓存击穿 缓存雪崩</h2><p>缓存穿透：说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p>缓存击穿： 大量请求的 key 不在缓存中但是在数据库里（一般都是缓存的时间到了就过期）</p>
<p>缓存雪崩：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong></p>
<h2 id="Redis常见的删除策略"><a href="#Redis常见的删除策略" class="headerlink" title="Redis常见的删除策略"></a>Redis常见的删除策略</h2><p>定时删除，TTL 结束就触发删除，对 CPU 不友好</p>
<p>惰性删除：使用的时候发现过期了才删除，但是会浪费内存空间</p>
<p>定期删除：每隔一段时间「随机」取出一定数量的 key 进行检查和删除</p>
<h2 id="描述用-Redis-实现验证码的存储和过期时间"><a href="#描述用-Redis-实现验证码的存储和过期时间" class="headerlink" title="描述用 Redis 实现验证码的存储和过期时间"></a>描述用 Redis 实现验证码的存储和过期时间</h2><p>用户请求验证码的时候进行验证码的生成，之后存储到 Redis 中，通过一个 Set 方法就可以同时实现过期时间的设置</p>
<p>之后用户携带验证码的时候从 Redis 中获取验证码，如果验证码正确且未过期，则验证成功；否则验证失败。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>LIMIT 子句来实现</p>
<p>分页通常需要两个参数：偏移量（offset）和行数（limit）。</p>
<p>基本的分页查询语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> your_table<br>LIMIT <span class="hljs-keyword">offset</span>, limit;<br></code></pre></td></tr></table></figure>

<p>其中，<code>offset</code>表示开始的行数，<code>limit</code>表示要选择的行数。</p>
<p>例如，如果你想获取从第 11 行开始的 10 条记录，查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> your_table<br>LIMIT <span class="hljs-number">10</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p>这将返回从第 11 行到第 20 行的记录。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>在 MySQL 中，索引是一种用于提高数据库查询性能的重要机制。索引是一种数据结构，类似于书籍目录，它提供了一种快速查找数据的方式，而不必扫描整个数据表。例如我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。下面是关于 MySQL 索引的一些基本概念</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p><strong>索引的作用：</strong></p>
<ul>
<li><strong>提高检索速度：</strong> 索引可以加快数据检索的速度，特别是在大型数据表中。</li>
<li><strong>加速排序：</strong> 对于排序和分组操作，索引也可以提高性能。</li>
<li><strong>唯一性约束：</strong> 索引可以强制表中的<strong>每一行数据</strong>的唯一性。</li>
</ul>
</li>
<li><p>索引的缺点</p>
<ul>
<li>创建和维护索引需要一定的性能开销</li>
<li>如果是批量插入上万行的数据，则需要针对这些插入语句关闭索引，否则会很慢很慢</li>
</ul>
</li>
</ol>
<h3 id="常见类型的索引：按照底层数据结构划分"><a href="#常见类型的索引：按照底层数据结构划分" class="headerlink" title="常见类型的索引：按照底层数据结构划分"></a>常见类型的索引：按照底层数据结构划分</h3><ul>
<li>B树</li>
<li>B+树</li>
<li>Hash表</li>
<li>红黑树</li>
</ul>
<p>无论是 InnoDB 还是 MyISam，采用的底层数据结构都是 B+ 树</p>
<h4 id="Hash表数据结构"><a href="#Hash表数据结构" class="headerlink" title="Hash表数据结构"></a>Hash表数据结构</h4><p>其实就是哈希函数映射+拉链法</p>
<p>和JDK1.8以前的实现方式差不多</p>
<p>哈希表虽然快，但是不支持顺序和范围查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tb1 <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure>

<p>像是这样的 SQL 就无法通过哈希表来实现</p>
<p>（TODO）</p>
<h3 id="常见类型的索引：按照应用维度划分"><a href="#常见类型的索引：按照应用维度划分" class="headerlink" title="常见类型的索引：按照应用维度划分"></a>常见类型的索引：按照应用维度划分</h3><ul>
<li><strong>主键索引（Primary Key Index）：</strong> 数据表的主键列使用的就是主键索引，是一种唯一性索引，用于唯一标识表中的每一行记录。一个表只能有一个主键索引。</li>
<li><strong>唯一索引（Unique Index）：</strong> 唯一索引确保索引列中的所有值都是唯一的，但允许空值。</li>
<li><strong>普通索引（Normal Index）：</strong> 普通索引是最基本的索引类型，没有唯一性限制。</li>
<li><strong>全文索引（Full-Text Index）：</strong> 用于全文搜索，适用于对文本数据进行搜索的场景。</li>
<li>唯一索引、普通索引、全文索引，都属于二级索引，他们的叶子节点存储的数据是主键的值</li>
</ul>
<p>InnoDB存储引擎使用的是B树索引结构。B树（或B+树）是一种平衡树结构，它在插入、删除和查找操作上具有较好的性能表现，适用于范围查询和排序操作。InnoDB的主键索引和普通索引都是基于B树的。</p>
<h2 id="事务带来的问题"><a href="#事务带来的问题" class="headerlink" title="事务带来的问题"></a>事务带来的问题</h2><p>脏读 幻读 不可重复读</p>
<h2 id="SQL定义的四个隔离级别"><a href="#SQL定义的四个隔离级别" class="headerlink" title="SQL定义的四个隔离级别"></a>SQL定义的四个隔离级别</h2><p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@tx</span>_isolation;<br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> @<span class="hljs-variable">@tx</span>_isolation  <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br><span class="hljs-operator">|</span> REPEATABLE<span class="hljs-operator">-</span>READ <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-----------------+</span><br></code></pre></td></tr></table></figure>

<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>除了 InnoDB 和 MyISAM 外还有什么</p>
<p><strong>MEMORY</strong></p>
<p><strong>CSV</strong>文件</p>
<h2 id="一百万条数据插入MySQL，有什么好的处理方法么"><a href="#一百万条数据插入MySQL，有什么好的处理方法么" class="headerlink" title="一百万条数据插入MySQL，有什么好的处理方法么"></a>一百万条数据插入MySQL，有什么好的处理方法么</h2><p>禁用索引</p>
<p>用 preparedStatement 预编译SQL语句批处理插入</p>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>JDBC（Java Database Connectivity）是<strong>Java程序与关系型数据库进行交互的一种标准接口</strong>。它提供了一组用于访问和操作数据库的Java API，允许Java应用程序与各种关系型数据库进行通信，如 MySQL、Oracle、SQL Server 等。</p>
<p>JDBC的主要组成部分包括：</p>
<ol>
<li><strong>DriverManager：</strong> 用于管理一组数据库驱动程序，负责建立与数据库的连接。</li>
<li><strong>Driver：</strong> JDBC驱动程序是一个实现JDBC接口的类，它充当Java应用程序与数据库之间的桥梁。不同的数据库需要使用相应的JDBC驱动。</li>
<li><strong>Connection：</strong> 表示与数据库的连接。通过<code>DriverManager.getConnection</code>方法获取数据库连接。</li>
<li><strong>Statement：</strong> 用于执行SQL语句。<code>Statement</code> 接口有三个主要的实现类：<code>Statement</code>、<code>PreparedStatement</code> 和 <code>CallableStatement</code>。</li>
<li><strong>ResultSet：</strong> 表示数据库结果集，是通过执行查询获取的数据集合。</li>
</ol>
<h2 id="JDBC中的事务是如何管理的？"><a href="#JDBC中的事务是如何管理的？" class="headerlink" title="JDBC中的事务是如何管理的？"></a><strong>JDBC中的事务是如何管理的？</strong></h2><p>在JDBC中，事务管理主要通过<code>Connection</code>接口的<code>commit()</code>和<code>rollback()</code>方法来实现</p>
<p>当所有SQL语句执行完成后，通过<code>commit()</code>提交事务；如果出现错误或需要回滚，则调用<code>rollback()</code>方法</p>
<p>默认情况下，每个SQL语句都是一个事务，如果需要手动管理事务，可以使用<code>setAutoCommit(false)</code>关闭自动提交。</p>
<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="动态SQL如何实现"><a href="#动态SQL如何实现" class="headerlink" title="动态SQL如何实现"></a>动态SQL如何实现</h2><p>MyBatis中的动态SQL允许你在映射文件中编写灵活的SQL语句，根据不同的条件生成不同的SQL片段，以满足动态查询的需求。动态SQL通常使用<code>&lt;if&gt;</code>, <code>&lt;choose&gt;</code>, <code>&lt;when&gt;</code>, <code>&lt;otherwise&gt;</code>, <code>&lt;trim&gt;</code>, <code>&lt;set&gt;</code>, <code>&lt;where&gt;</code>, <code>&lt;foreach&gt;</code>等标签来实现</p>
<h2 id="分页如何实现"><a href="#分页如何实现" class="headerlink" title="分页如何实现"></a>分页如何实现</h2><p>MyBatis 提供了 <code>RowBounds</code> 类，通过将 <code>RowBounds</code> 作为方法的参数来实现分页</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">(RowBounds rowBounds)</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    SELECT * FROM users<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">RowBounds</span> <span class="hljs-variable">rowBounds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RowBounds</span>(offset, limit);<br>List&lt;User&gt; userList = userDao.getUserList(rowBounds);<br></code></pre></td></tr></table></figure>

<h2 id="和-的区别是？"><a href="#和-的区别是？" class="headerlink" title="#{}和${}的区别是？"></a>#{}和${}的区别是？</h2><p>${}是properties文件的变量占位符，可以用在配置文件或者是 SQL 语句中</p>
<p>例如：根据参数按任意字段排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $&#123;orderControls&#125;<br></code></pre></td></tr></table></figure>

<p><code>orderControls</code>可以是 <code>name</code>、<code>name desc</code>、<code>name,sex asc</code>等，实现灵活的排序</p>
<p>而 #{} 是SQL的参数占位符，Mybatis会将其设置为 ？ 并且在执行的过程中由 preparedStatement 来设置参数值</p>
<h1 id="Tomcat-amp-Servlet"><a href="#Tomcat-amp-Servlet" class="headerlink" title="Tomcat &amp; Servlet"></a>Tomcat &amp; Servlet</h1><h2 id="什么是Tomcat？它与Web服务器的区别是什么？"><a href="#什么是Tomcat？它与Web服务器的区别是什么？" class="headerlink" title="什么是Tomcat？它与Web服务器的区别是什么？"></a><strong>什么是Tomcat？它与Web服务器的区别是什么？</strong></h2><p>Tomcat是一个开源的、轻量级的、<strong>用于运行Java Servlet和JSP的Web应用服务器</strong></p>
<p>它与传统的Web服务器（如Apache HTTP Server）的区别在于Tomcat<strong>更专注于Java Servlet和JSP技术的支持</strong>，而不仅仅是提供静态文件服务。</p>
<h2 id="Tomcat-运行流程"><a href="#Tomcat-运行流程" class="headerlink" title="Tomcat 运行流程"></a>Tomcat 运行流程</h2><p>Tomcat的运行流程可以简单概括为以下几个步骤：</p>
<ol>
<li><strong>启动阶段：</strong><ul>
<li>当Tomcat启动时，会加载并初始化服务器组件。在这个阶段，Tomcat会读取配置文件（主要是 <code>server.xml</code> 文件）来配置连接器、虚拟主机、Web应用等信息。</li>
</ul>
</li>
<li><strong>监听端口：</strong><ul>
<li>连接器（Connector）负责监听指定的端口，等待客户端的请求。常见的连接器有HTTP&#x2F;1.1连接器、AJP连接器等。</li>
</ul>
</li>
<li><strong>接收请求：</strong><ul>
<li>当有请求到达时，连接器将请求交给 Catalina 容器进行处理。Catalina是Tomcat的Servlet容器，负责处理Servlet和JSP。</li>
</ul>
</li>
<li><strong>处理请求：</strong><ul>
<li>Catalina根据请求的URL和虚拟主机等信息，将请求交给对应的Host（主机）。Host根据Context的配置将请求分发给对应的Web应用。</li>
</ul>
</li>
<li><strong>Web应用处理：</strong><ul>
<li>Web应用处理阶段涉及多个组件，包括ClassLoader、Context、Wrapper等。ClassLoader加载Web应用的类，Context提供Web应用的运行环境，Wrapper负责实际的Servlet执行。</li>
</ul>
</li>
<li><strong>Servlet执行：</strong><ul>
<li>当请求到达目标Servlet时，Wrapper将请求转发给Servlet进行处理。Servlet执行相应的逻辑，生成响应内容。</li>
</ul>
</li>
<li><strong>生成响应：</strong><ul>
<li>Servlet生成响应后，将响应返回给Catalina容器，然后由Catalina返回给连接器。</li>
</ul>
</li>
<li><strong>连接器响应：</strong><ul>
<li>连接器将响应发送给客户端，完成请求-响应周期。</li>
</ul>
</li>
<li><strong>关闭阶段：</strong><ul>
<li>当Tomcat关闭时，会执行关闭阶段。在这个阶段，Tomcat会释放资源、关闭连接器等。</li>
</ul>
</li>
</ol>
<h2 id="简单介绍-Servlet"><a href="#简单介绍-Servlet" class="headerlink" title="简单介绍 Servlet"></a>简单介绍 Servlet</h2><p>Servlet（Serverlet）是Java编写的服务器端程序，主要用于扩展服务器功能。Servlet在Web开发中广泛使用，它是Java EE（Enterprise Edition）平台的一部分，用于处理Web请求和响应</p>
<h1 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h1><h2 id="基本组件和概念"><a href="#基本组件和概念" class="headerlink" title="基本组件和概念"></a>基本组件和概念</h2><h2 id="你在项目中用到了哪些功能"><a href="#你在项目中用到了哪些功能" class="headerlink" title="你在项目中用到了哪些功能"></a>你在项目中用到了哪些功能</h2><h2 id="pod网络"><a href="#pod网络" class="headerlink" title="pod网络"></a>pod网络</h2><h1 id="笔试刷题错题"><a href="#笔试刷题错题" class="headerlink" title="笔试刷题错题"></a>笔试刷题错题</h1><h2 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h2><p>左半部分不应该指定大小，下面这种都不是 Java 的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[<span class="hljs-number">5</span>] a= &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>Integer[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] a = &#123;&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">2</span>)&#125;,&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">3</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Interger</span>(<span class="hljs-number">4</span>)&#125;&#125;;<br></code></pre></td></tr></table></figure>

<p>此外，创建二维数组的时候不能先创建第二层，至少也得先声明第一层的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Float[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float</span>[][<span class="hljs-number">5</span>]; <span class="hljs-comment">//这种就不对</span><br>Fload[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float</span>[<span class="hljs-number">5</span>][]; <span class="hljs-comment">//这种可以</span><br></code></pre></td></tr></table></figure>

<h2 id="声明作用域"><a href="#声明作用域" class="headerlink" title="声明作用域"></a>声明作用域</h2><p>private:  仅限类的内部 </p>
<p>pakage: 包内类可以访问</p>
<p>default: 同一个包可见</p>
<p>protect: 包内类可以访问，另外包外子类也可以访问</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类可以实现接口，且<strong>不必实现接口中的抽象方法</strong></p>
<p>抽象类可以没有抽象方法，也可以有抽象方法+具体方法</p>
<p>抽象类和接口<strong>不能实例化</strong></p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="包装数据类型变量-a"><a href="#包装数据类型变量-a" class="headerlink" title="包装数据类型变量 ++a"></a>包装数据类型变量 ++a</h3><p>核心考点：</p>
<ul>
<li>数据机器级表示</li>
<li>包装类自动装箱拆箱</li>
</ul>
<p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20240101165746438.png" srcset="/img/loading.gif" lazyload></p>
<p>核心解法：</p>
<ul>
<li>++a先是触发拆箱操作Byte.byteValue，得到基本类型的值127，然后执行+1操作，使得值变为-128，最后触发装箱操作Byte.valueOf将value&#x3D;-128的Byte对象赋值给a</li>
<li>至于为什么是 -128 这是CSAPP和计算机组成原理的知识</li>
<li>add方法里那一段其实没有任何作用，实际上这个<strong>和自增也没啥关系</strong>，就算是你改成 <code>b = ++b</code> 由于<strong>包装类作为参数的时候传递的是值而不是引用</strong>，因此无论是 <code>++b</code> 还是 <code>b++</code> 都不会修改到 test() 声明的 b 的值</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一个新创建的线程<strong>并不是自动的开始运行的</strong>，必须调用它的start()方法使之将线程放入可<strong>运行态(runnable state)</strong>     </p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>ArrayList 初始化之后第一次扩容的逻辑：通过新建一个数组，再通过 <code>System.arrayCopy</code> 的方式将旧数据移植新数组中</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="事务相关的指令"><a href="#事务相关的指令" class="headerlink" title="事务相关的指令"></a>事务相关的指令</h3><p>Commit 用于事物的显示提交 </p>
<p><strong>savepoint</strong> 用于在 sql 语句中设置事物保存点，用法为 <code>savepoint 保存点名称</code> ，在 rollback 时使用 </p>
<p>rollback [work] to [savepoint] 回滚到某个保存点</p>
<p>需要注意的是我们都知道 commit 和 rollback 但是 savepoint 不是很熟</p>
<hr>
<p>正常执行完DDL语句。包括 create，alter，drop，truncate，rename</p>
<p>正常执行完DCL语句。包括 grant，revoke</p>
<p>正常退出数据库管理软件，没有明确发出 commit 或者 rollback</p>
<p>除了基本的查询语句与增删改的对表的操纵语句外基本都是隐式提交的，使用时要注意。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>在定义视图的 SELECT 语句后的字段列表中使用 DISTINCT 、聚合函数 、 GROUP BY 、 HAVING 、UNION 等，视图将不支持INSERT、UPDATE、DELETE</p>
<h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><p>UNION ALL不去重，UNION<strong>去重</strong></p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p> 别名不可以用’’引起来<br> 别名可以用””引起来<br> 别名前面用不用as都可以</p>
<h3 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h3><p>索引是记录文件位置的特殊文件结构,他是保存在磁盘上的,所以<strong>不能直接被sql引用</strong></p>
<h3 id="纯概念"><a href="#纯概念" class="headerlink" title="纯概念"></a>纯概念</h3><p>数据库的独立性分为逻辑独立性和物理存储独立性。 </p>
<p>逻辑独立性是指应用程序独立与数据库的逻辑结构，当模式发生改变时，外模式不变从而使应用程序不变。 </p>
<p>物理独立性是指应用程序独立于数据的物理存储结构，当内模式发生改变时，模式不会发生改变，从而外模式也不会发生改变，从而使得应用程序不发生改变。 </p>
<p>模式&#x2F;外模式映射保证数据库的逻辑独立性 </p>
<p>内模式&#x2F;模式映射保证数据库的物理独立性。</p>
<h3 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231231161239265.png" srcset="/img/loading.gif" lazyload></p>
<p>1NF：指每一列是原子不可分割 </p>
<p>2NF：消除非主属性对主属性的部分依赖，也就是说每列都依赖主键，而不能与主键的部分相关，也就是<strong>不存在依赖与联合主键的情况</strong></p>
<p>3NF：关系中既不存在部分依赖，也不存在传递依赖的关系</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="空间计算"><a href="#空间计算" class="headerlink" title="空间计算"></a>空间计算</h3><p><img src="https://my-img-1.oss-cn-hangzhou.aliyuncs.com/image-20231231161120569.png" srcset="/img/loading.gif" lazyload></p>
<p> 7000H &#x3D; 0111 0000 0000 0000 </p>
<p> 8K&#x3D;2^13 &#x3D; 0010 0000 0000 0000 </p>
<p> 初始地址为7000H，则其8K长度的地址的终点为 </p>
<p> 7000H + 8K - 1&#x3D;&amp;nbsp;0111 0000 0000 0000 +&amp;nbsp;0010 0000 0000 0000 - 1 </p>
<p> &#x3D;0111 0000 0000 0000&amp;nbsp; </p>
<p> +0001 1111 1111&amp;nbsp;1111<br> &#x3D;1000 1111 1111 1111&#x3D;8FFFF(十六进制)</p>
<h2 id="计算机网络-1"><a href="#计算机网络-1" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="TCP重传"><a href="#TCP重传" class="headerlink" title="TCP重传"></a>TCP重传</h3><p>TCP使用<strong>超时事件</strong>和<strong>冗余ACK</strong>来检测数据包的丢失。</p>
<ul>
<li>当超时事件发生时，TCP会执行重传</li>
<li>此外，TCP还使用冗余ACK（冗余确认）来快速检测数据包的丢失，并在收到冗余ACK时触发快速重传</li>
</ul>
<p>在TCP中，超时时间是<strong>动态调整</strong>的，根据网络的延迟和拥塞情况进行调整，而不是固定的</p>
<p>TCP接收方通常<strong>需要对乱序到达的分组进行确认</strong>。TCP协议使用累积确认机制，<strong>接收方会发送一个确认号</strong>，<strong>表示已成功接收到这个序号之前的所有数据</strong>。如果接收方收到乱序的分组，它仍然会确认已经接收到的最后一个按序到达的分组，以指示发送方不需要重传已经成功接收的数据，但仍然需要重传丢失的数据。</p>
<h2 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h2><h3 id="垃圾回收策略"><a href="#垃圾回收策略" class="headerlink" title="垃圾回收策略"></a>垃圾回收策略</h3><p>新生代收集器： Serial、 ParNeW、Parallel Scavenge</p>
<p>老年代收集器： Serial Old、 Parallel Old、 CMS</p>
<p>整堆收集器： G1 （统管新生代和老年代）</p>
<h3 id="释放指定内存空间"><a href="#释放指定内存空间" class="headerlink" title="释放指定内存空间"></a>释放指定内存空间</h3><p>在Java中，释放掉一个指定占据的内存空间的方法是：</p>
<p>A：调用system.gc()方法 </p>
<p>B：调用free()方法 </p>
<p>C：赋值给该对象的引用为null </p>
<p>D：程序员无法明确强制垃圾回收器运行</p>
<p>在Java中，释放内存的具体操作是由垃圾回收器（Garbage Collector）负责的，而<strong>不是由程序员手动释放</strong>。因此，程序员不能直接明确强制垃圾回收器运行</p>
<p>A：<code>System.gc()</code>方法调用<strong>是建议垃圾回收器运行</strong>，但并不能保证立即执行。</p>
<p>B：<code>free()</code>方法在Java中通常不是程序员用来释放内存的方法，而是在C语言中使用。</p>
<p>C：赋值给该对象的引用为null并不能直接释放内存。<strong>垃圾回收器会在适当的时候发现这个对象没有被引用，然后将其回收</strong>。</p>
<p>D：程序员无法明确强制垃圾回收器运行，这是Java设计的一部分，以避免程序员过多地涉及内存管理。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="可以判断有向图是否带环的算法"><a href="#可以判断有向图是否带环的算法" class="headerlink" title="可以判断有向图是否带环的算法"></a>可以判断有向图是否带环的算法</h3><ul>
<li>DFS</li>
<li>拓扑排序</li>
</ul>
<h1 id="OLK"><a href="#OLK" class="headerlink" title="OLK"></a>OLK</h1><h2 id="SPI-机制"><a href="#SPI-机制" class="headerlink" title="SPI 机制"></a>SPI 机制</h2><h3 id="SPI和API"><a href="#SPI和API" class="headerlink" title="SPI和API"></a>SPI和API</h3><p>简单来说，API是接口和实现都放在实现方，实现对调用者透明，是<strong>实现方定义了接口的规则</strong>，<strong>调用者调用实现方提供的接口</strong></p>
<p>而SPI是接口由<strong>调用方来定义规则</strong>，实现方基于调用方接口的定义，来实现调用方定义的接口</p>
<h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2><h3 id="外部函数注册-amp-下推"><a href="#外部函数注册-amp-下推" class="headerlink" title="外部函数注册&amp;下推"></a>外部函数注册&amp;下推</h3><p>继承抽象类</p>
<p>注绑定字符串，数字运算，日期相关的函数</p>
<h3 id="MariaClientModule绑定配置"><a href="#MariaClientModule绑定配置" class="headerlink" title="MariaClientModule绑定配置"></a>MariaClientModule绑定配置</h3><p>注册绑定 Client Module 的时候针对配置文件中的 URL 处理，MySQL 和 MariaDB 实现不一样</p>
<p>MariaDB 由驱动提供的 UrlParser类来实现</p>
<p>此外获取数据库的时候一些判断也根据不同的 Driver 进行上层的实现</p>
<h3 id="编写流程"><a href="#编写流程" class="headerlink" title="编写流程"></a>编写流程</h3><p>注册 Module，配置一些连接器元数据信息，包括 catalog schema 名称等</p>
<p>绑定 Client 对象，外部函数以及配置文件的信息（实体化为Config类）</p>
<p>MariaClient 代表一个 JDBC 客户端对象，基于JDBC来操作数据源，是在BaseJdbcClient基础上针对MairaDB的一套适配，一些异常ErrorCode进行了适配</p>
<h2 id="最难的问题"><a href="#最难的问题" class="headerlink" title="最难的问题"></a>最难的问题</h2><p>在集成测试的时候，社区要求的引入的 airlift 包里通过代码创建了 mysqld 进程，但是默认是root身份启动，不允许，因此学习修改源码修改启动的 mysqld 的相关配置，允许 root 启动</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CS-Basic/" class="category-chain-item">CS_Basic</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java 八股</div>
      <div>http://example.com/2024/01/05/Java 面试/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Noctis64</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/23/CMU-15-213-Machine-Level-Programming-Control/" title="CMU 15-213|Machine Level Programming-Control">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMU 15-213|Machine Level Programming-Control</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/01/PS2-hack-Vol-1-%E6%84%9F%E6%9F%93%E6%89%A9%E5%A4%A7/" title="PS2|.hack// Vol.1 感染扩大">
                        <span class="hidden-mobile">PS2|.hack// Vol.1 感染扩大</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
